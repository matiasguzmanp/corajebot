#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""hide&seek.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14tcleJ0YusKPP-YivgD15riTcqFstaSA
"""

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from time import time
import math
import yaml
from scipy.signal import convolve2d

def mark_visible_cells(grid, pos_observer, visibility_range, mark_value=1):
    y_obs, x_obs = pos_observer

    for x in range(len(grid)):
        for y in range(len(grid[0])):
            if grid[x][y] != 0:  # Skip occupied cells
                dx = x - x_obs
                dy = y - y_obs
                distance = math.sqrt(dx**2 + dy**2)
                if distance <= visibility_range:
                    is_visible = is_clear_line_of_sight(grid, pos_observer, (x, y))
                    if is_visible:
                        grid[x][y] = mark_value

    kernel = np.ones((2,2), np.uint8)
    grid = cv.erode(grid, kernel)
    return grid

def is_clear_line_of_sight(grid, start, end):
    y1, x1 = start
    x2, y2 = end
    dx = x2 - x1
    dy = y2 - y1
    distance = max(abs(dx), abs(dy))
    dx /= (distance+0.01)
    dy /= (distance+0.01)
    x = x1
    y = y1

    for _ in range(int(distance)):
        x += dx
        y += dy
        if grid[int(x)][int(y)] == 0:  # Occupied cell
            return False

    return True

def whereCanRobotFit(map, robot):
  filtered_img = convolve2d(map, robot, mode='same', boundary='fill', fillvalue=0)
  normalized_array = cv.normalize(filtered_img, None, 0, 255, cv.NORM_MINMAX)
  _, fit = cv.threshold(normalized_array, 250, 255, cv.THRESH_BINARY)
  
  return fit

def manhattan_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return abs(x1 - x2) + abs(y1 - y2)

def calculateDistances(map, point):
  x,y = point
  L = np.zeros(map.shape)
  for i in range(map.shape[0]):
    for j in range(map.shape[1]):
      if map[i,j] == 255:
        dist = manhattan_distance((x,y),(i,j))
        L[i,j] = 1/dist
  return L

def process_map(map, scale_percent = 50, display = 0):
    # resize map
    width = int(map.shape[1] * scale_percent / 100)
    height = int(map.shape[0] * scale_percent / 100)
    dim = (width, height)

    resized = cv.resize(map, dim, interpolation = cv.INTER_AREA)

    # cut map
    min_x, max_x, min_y, max_y = [80, 270, 60, 200]
    #min_x, max_x, min_y, max_y = [150, 550, 100, 400]
    cut_map = resized[min_x : max_x, min_y : max_y]

    _, occupancy_data = cv.threshold(cut_map, 250, 255,cv.THRESH_BINARY)
    kernel = np.ones((3,3), np.uint8)
    occupancy_data = cv.erode(occupancy_data, kernel)
    if display:
        plt.imshow(occupancy_data, cmap='gray')
    return occupancy_data

def createRobotFootprint(resolution=0.02):
    # digamos que el robot se puede aproximar por un circulo con r=50 cm
    real_dim = 0.5
    robot_pix = int(real_dim/resolution)
    robot_footprint = np.zeros((robot_pix + 2, robot_pix + 2))
    center = (int(robot_footprint.shape[0]/2), int(robot_footprint.shape[1]/2))
    robot_footprint= cv.circle(robot_footprint, center, int(robot_footprint.shape[0]/2), 255, -1)
    return robot_footprint


def point_to_original_size(xy_hidingplace):
    original_i = xy_hidingplace[0]*2
    original_j = xy_hidingplace[1]*2

    return original_i, original_j

def map_to_orig (map, orig_size, scale_percent = 200):
    width = int(orig_size[1] * scale_percent / 100)
    height = int(orig_size[0] * scale_percent / 100)
    dim = (width, height)

    # resize image
    final = cv.resize(map, dim, interpolation = cv.INTER_AREA)

    return final
    
def find_hiding_place(map, resolution, origin, paparazzi, robot, display=True, range = 300):
    t0 = time()
    possible_hiding_points_raw = mark_visible_cells(map.copy(), paparazzi, range)
    print('Exec time: %f'%(time()-t0))

    kernel = np.ones((3, 3), np.uint8)
    possible_hiding_points = cv.erode(possible_hiding_points_raw, kernel)
    robot_footprint = createRobotFootprint(resolution)
    valid_points_map = whereCanRobotFit(possible_hiding_points, robot_footprint)
    distances_from_point = calculateDistances(valid_points_map, robot) #calculate distances from robot, so we find the closest one
    max_indices = np.unravel_index(np.argmax(distances_from_point), distances_from_point.shape)

    if display:
        plt.imshow(map, cmap='gray')
        plt.scatter(paparazzi[0], paparazzi[1])

    return max_indices

if __name__=="__main__":
   print("This is a library! Try to import functions")