#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""hide&seek.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14tcleJ0YusKPP-YivgD15riTcqFstaSA
"""

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from time import time
import math
import yaml
from scipy.signal import convolve2d
import rospy
from nav_msgs.msg import OccupancyGrid

def manhattan_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return abs(x1 - x2) + abs(y1 - y2)

def mark_visible_cells(grid, pos_observer, visibility_range, mark_value=1):
    y_obs, x_obs = pos_observer

    for x in range(len(grid)):
        for y in range(len(grid[0])):
            if grid[x][y] != 0:  # Skip occupied cells
                dx = x - x_obs
                dy = y - y_obs
                distance = math.sqrt(dx**2 + dy**2)
                if distance <= visibility_range:
                    is_visible = is_clear_line_of_sight(grid, pos_observer, (x, y))
                    if is_visible:
                        grid[x][y] = mark_value

    kernel = np.ones((2,2), np.uint8)
    grid = cv.erode(grid, kernel)
    return grid

def is_clear_line_of_sight(grid, start, end):
    y1, x1 = start
    x2, y2 = end
    dx = x2 - x1
    dy = y2 - y1
    distance = max(abs(dx), abs(dy))
    dx /= (distance+0.01)
    dy /= (distance+0.01)
    x = x1
    y = y1

    for _ in range(int(distance)):
        x += dx
        y += dy
        if grid[int(x)][int(y)] == 0:  # Occupied cell
            return False

    return True


class FindPlaceToHide:
    
    def __init__(self):
        # map data
        self.original_map = None
        self.scaled_map = None
        self.origin = None
        self.resolution = None
        self.scale_percent = 50
    
        # debug
        self.distances_from_point = None
        self.fit = None
        self.max_indices = None
        self.posible_hiding_points = None
        self.paparazzi_in_pixels = None
        self.robot_in_pixels = None
        self.valid_hiding_points = None



    def load_map(self, data, width, height, origin, resolution):
        self.origin = origin
        self.resolution = resolution
        self.original_map = self.create_map(data, width, height)
        self.scaled_map = self.process_map()
        self.robot_footprint = self.createRobotFootprint()

    def create_map(self, data, width, height):
        occupancy_grid = np.array(data).reshape((height, width))
        map = np.zeros((height, width), dtype=np.uint8)
        map[occupancy_grid == 0] = 255  # Celdas libres en blanco
        map[occupancy_grid == 100] = 0  # Celdas ocupadas en negro
        map[occupancy_grid == -1] = 0
        return map

    def process_map(self):
        #Resize and cut map for performance reasons
        width = int(self.original_map.shape[1] * self.scale_percent / 100)
        height = int(self.original_map.shape[0] * self.scale_percent / 100)
        dim = (width, height)

        resized = cv.resize(self.original_map, dim, interpolation = cv.INTER_AREA)

        _, occupancy_data = cv.threshold(resized, 250, 255,cv.THRESH_BINARY)
        kernel = np.ones((3,3), np.uint8)
        occupancy_data = cv.erode(occupancy_data, kernel)

        return occupancy_data


    def createRobotFootprint(self, real_dim=0.5):
        # digamos que el robot se puede aproximar por un circulo con r=50 cm
        robot_pix = int(real_dim*self.resolution)
        robot_footprint = np.zeros((robot_pix + 2, robot_pix + 2))
        center = (int(robot_footprint.shape[0]/2), int(robot_footprint.shape[1]/2))
        robot_footprint= cv.circle(robot_footprint, center, int(robot_footprint.shape[0]/2), 255, -1)

        return robot_footprint
    
    def whereCanTheRobotBe(self, posible_hiding_points):
        filtered_img = convolve2d(posible_hiding_points, self.robot_footprint, mode='same', boundary='fill', fillvalue=0)
        normalized_array = cv.normalize(filtered_img, None, 0, 255, cv.NORM_MINMAX)
        _, fit = cv.threshold(normalized_array, 250, 255, cv.THRESH_BINARY)
        return fit


    def point_to_original_size(self, xy_hidingplace):
        original_i = xy_hidingplace[0]/(self.scale_percent*0.01)
        original_j = xy_hidingplace[1]/(self.scale_percent*0.01)

        return original_i, original_j
    
    def calculateDistances(self, valid_hiding_points, point):
        y,x = point
        L = np.zeros(self.valid_hiding_points.shape)
        for i in range(self.valid_hiding_points.shape[0]):
            for j in range(self.valid_hiding_points.shape[1]):
                if self.valid_hiding_points[i,j] == 255:
                    dist = manhattan_distance((x,y),(i,j))
                    L[i,j] = 1/dist
        return L

    def process_points(self, paparazzi, robot):
        scale = (((self.scale_percent)*0.01))
        paparazzi = paparazzi[0]*scale, paparazzi[1]*scale
        robot = robot[0]*scale, robot[1]*scale
        return paparazzi, robot

    def find_hiding_place(self, paparazzi_xyz, robot_xyz, display=False, range = 300):
        paparazzi_pixels = int((paparazzi_xyz[0] - self.origin[0]) / self.resolution), int((paparazzi_xyz[1] - self.origin[1]) / self.resolution)
        robot_pixels = int((robot_xyz[0] - self.origin[0]) / self.resolution), int((robot_xyz[1] - self.origin[1]) / self.resolution)
        self.paparazzi_in_pixels = paparazzi_pixels
        self.robot_in_pixels = robot_pixels
        
        paparazzi, robot = self.process_points(paparazzi_pixels, robot_pixels)

        t0 = time()
        posible_hiding_points_raw = mark_visible_cells(self.scaled_map, paparazzi, range)
        print('Exec time: %f'%(time()-t0))

        posible_hiding_points = cv.erode(posible_hiding_points_raw, kernel=np.ones((3, 3), np.uint8))
        self.posible_hiding_points = posible_hiding_points_raw

        valid_hiding_points = self.whereCanTheRobotBe(posible_hiding_points)
        self.valid_hiding_points = valid_hiding_points

        distances_from_point = self.calculateDistances(valid_hiding_points, robot) #calculate distances from robot, so we can find the closest one
        self.distances_from_point = distances_from_point
        max_indices = np.unravel_index(np.argmax(distances_from_point), distances_from_point.shape)
        self.max_indices = max_indices

        px, py = self.point_to_original_size(max_indices)
        x,y = self.origin[0] + px*self.resolution, self.origin[1] + py*self.resolution

        return (py,px),(y,x)


if __name__=="__main__":
    rospy.init_node("XD")
    finder = FindPlaceToHide()
    msg = rospy.wait_for_message("/map", OccupancyGrid)
    data = msg.data
    origin = [msg.info.origin.position.x, msg.info.origin.position.y, msg.info.origin.position.z]
    resolution = msg.info.resolution
    width = msg.info.width
    height = msg.info.height
    finder.load_map(data,width,height,origin,resolution)
    paparazzi = (0.64, 5.0)
    robot = (0.64, 3.22)
    pixels, points = finder.find_hiding_place(paparazzi_xyz = paparazzi, robot_xyz=robot)
    
    #
    # plt.imshow(finder.original_map, cmap='gray')
    #plt.scatter(finder.max_indices[1], finder.max_indices[0])
    #plt.scatter(finder.paparazzi_in_pixels[0], finder.paparazzi_in_pixels[1])
    #plt.scatter(finder.robot_in_pixels[0], finder.robot_in_pixels[1], marker='x')
    #plt.scatter(pixels[0],pixels[1])

    #plt.imshow(finder.valid_points_map, cmap='gray')
    #plt.scatter(paparazzi[0], paparazzi[1])
    #plt.scatter(robot[0], robot[1])
    #plt.show()