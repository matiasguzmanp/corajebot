#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""hide&seek.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14tcleJ0YusKPP-YivgD15riTcqFstaSA
"""

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from time import time
import math
import yaml
from scipy.signal import convolve2d

def manhattan_distance(point1, point2):
    x1, y1 = point1
    x2, y2 = point2
    return abs(x1 - x2) + abs(y1 - y2)

def mark_visible_cells(grid, pos_observer, visibility_range, mark_value=1):
    y_obs, x_obs = pos_observer

    for x in range(len(grid)):
        for y in range(len(grid[0])):
            if grid[x][y] != 0:  # Skip occupied cells
                dx = x - x_obs
                dy = y - y_obs
                distance = math.sqrt(dx**2 + dy**2)
                if distance <= visibility_range:
                    is_visible = is_clear_line_of_sight(grid, pos_observer, (x, y))
                    if is_visible:
                        grid[x][y] = mark_value

    kernel = np.ones((2,2), np.uint8)
    grid = cv.erode(grid, kernel)
    return grid

def is_clear_line_of_sight(grid, start, end):
    y1, x1 = start
    x2, y2 = end
    dx = x2 - x1
    dy = y2 - y1
    distance = max(abs(dx), abs(dy))
    dx /= (distance+0.01)
    dy /= (distance+0.01)
    x = x1
    y = y1

    for _ in range(int(distance)):
        x += dx
        y += dy
        if grid[int(x)][int(y)] == 0:  # Occupied cell
            return False

    return True


class FindPlaceToHide:
    
    def __init__(self, map, origin, resolution):
        self.original_map = map
        self.origin = origin
        self.resolution = resolution

        # debug
        self.L = None
        self.fit = None
        self.max_indices = None
        self.posible_hiding_points = None
        self.paparazzi_scaled = None
        self.robot_scaled = None
        self.valid_points_map = None

        # Process map
        self.scale_percent = 50
        [self.min_x, self.max_x, self.min_y, self.max_y] = [80, 270, 60, 200]
        self.scaled_map = self.process_map()

        # Robot footprint in map
        self.robot_footprint = self.createRobotFootprint()
        
    def process_map(self):
        #Resize and Cut map for performance reasons
        width = int(self.original_map.shape[1] * self.scale_percent / 100)
        height = int(self.original_map.shape[0] * self.scale_percent / 100)
        dim = (width, height)

        resized = cv.resize(self.original_map, dim, interpolation = cv.INTER_AREA)
        #cut_map = resized[self.min_x : self.max_x, self.min_y : self.max_y]

        _, occupancy_data = cv.threshold(resized, 250, 255,cv.THRESH_BINARY)
        kernel = np.ones((3,3), np.uint8)
        occupancy_data = cv.erode(occupancy_data, kernel)

        return occupancy_data


    def createRobotFootprint(self, real_dim=0.5):
        # digamos que el robot se puede aproximar por un circulo con r=50 cm
        robot_pix = int(real_dim/self.resolution)
        robot_footprint = np.zeros((robot_pix + 2, robot_pix + 2))
        center = (int(robot_footprint.shape[0]/2), int(robot_footprint.shape[1]/2))
        robot_footprint= cv.circle(robot_footprint, center, int(robot_footprint.shape[0]/2), 255, -1)

        return robot_footprint
    
    def WhereCanTheRobotBe(self, posible_hiding_points):
        filtered_img = convolve2d(posible_hiding_points, self.robot_footprint, mode='same', boundary='fill', fillvalue=0)
        normalized_array = cv.normalize(filtered_img, None, 0, 255, cv.NORM_MINMAX)
        _, fit = cv.threshold(normalized_array, 250, 255, cv.THRESH_BINARY)

        self.fit = fit
        return fit


    def point_to_original_size(self, xy_hidingplace):
        original_i = xy_hidingplace[0]/(self.scale_percent*0.01)
        original_j = xy_hidingplace[1]/(self.scale_percent*0.01)

        return original_i, original_j
    
    def calculateDistances(self, valid_points_map, point):
        x,y = point
        L = np.zeros(self.valid_points_map.shape)
        for i in range(self.valid_points_map.shape[0]):
            for j in range(self.valid_points_map.shape[1]):
                if self.valid_points_map[i,j] == 255:
                    dist = manhattan_distance((x,y),(i,j))
                    L[i,j] = 1/dist
        return L

    def process_points(self, paparazzi, robot):
        scale = (((self.scale_percent)*0.01))
        paparazzi = paparazzi[0]*scale, paparazzi[1]*scale
        robot = robot[0]*scale, robot[1]*scale
        self.paparazzi_scaled = paparazzi
        self.robot_scaled = robot
        return paparazzi, robot

    def find_hiding_place(self, paparazzi_orig, robot_orig, display=False, range = 300):
        paparazzi, robot = self.process_points(paparazzi_orig, robot_orig)
        t0 = time()
        posible_hiding_points_raw = mark_visible_cells(self.scaled_map, paparazzi, range)
        print('Exec time: %f'%(time()-t0))
        posible_hiding_points = cv.erode(posible_hiding_points_raw, kernel=np.ones((3, 3), np.uint8))
        self.posible_hiding_points = posible_hiding_points_raw

        valid_points_map = self.WhereCanTheRobotBe(posible_hiding_points)
        self.valid_points_map = valid_points_map
        distances_from_point = self.calculateDistances(valid_points_map, robot) #calculate distances from robot, so we can find the closest one
        self.L = distances_from_point
        max_indices = np.unravel_index(np.argmax(distances_from_point), distances_from_point.shape)
        self.max_indices = max_indices

        px, py = self.point_to_original_size(max_indices)
        x,y = self.origin[0] + px*self.resolution, self.origin[1] + py*self.resolution

        if display:
            plt.imshow(self.original_map, cmap='gray')
            plt.scatter(paparazzi_orig[0], paparazzi_orig[1])

        return (py,px),(y,x)


if __name__=="__main__":
    pass